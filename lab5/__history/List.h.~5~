//---------------------------------------------------------------------------

#ifndef ListH
#define ListH
#include "Queue.h"

template <typename T>
class List
{
public:
	List();

	~List();

	void PopBack();

	void PushFront(T);

	void Insert(T, int);

	void RemoveAt(int);

	void PopFront();

	void InsertList(List<T>&, int);

	void PushBack(T);

	int GetSize();

	T& operator[](const int);
private:

	int size;

	Node<T>* head;

	Node<T>* tail;
};

template <typename T>
List<T>::List()
{
	size = 0;
	head = nullptr;
	tail = nullptr;
}

template <typename T>
void List<T>::PopBack()
{
	if (size == 1)
	{
		delete tail;
		head = nullptr;
		tail = nullptr;
		size--;
		return;
	}
	tail = tail->prev;
	delete tail->next;
	tail->next = nullptr;
	size--;
}

template <typename T>
void List<T>::PushFront(T data)
{
	if (head == nullptr)
	{
		head = tail = new Node<T>(data);
	}
	else
	{
		head->prev = new Node<T>(data, nullptr, head);
		head = head->prev;
	}
	size++;
}

template <typename T>
void List<T>::Insert(T data, int index)
{
	Node<T>* current;
	if (index == 0)
	{
		PushFront(data);
		return;
	}
	else if (index == size)
	{
		PushBack(data);
		return;
	}
	else if (index <= size / 2)
	{
		current = head;
		for (int i = 0; i < index - 1; i++)
		{
			current = current->next;
		}
	}
	else
	{
		current = tail;
		for (int i = size - 1; i > index - 1; i--)
		{
			current = current->prev;
		}
	}
	current->next = new Node<T>(data, current, current->next);
	current->next->next->prev = current->next;
	size++;
}

template <typename T>
void List<T>::RemoveAt(int index)
{
	if (index == 0)
	{
		PopFront();
	}
	else if (index == size - 1)
	{
		PopBack();
	}
	else if (index <= size / 2)
	{
		Node<T>* current = this->head;
		for (int i = 0; i < index - 1; i++)
		{
			current = current->next;
		}
		Node<T>* todelete = current->next;
		current->next = todelete->next;
		todelete->next->prev = current;
		delete todelete;
		size--;
	}
	else
	{
		Node<T>* current = this->tail;
		for (int i = size - 1; i > index - 2; i--)
		{
			current = current->prev;
		}
		Node<T>* todelete = current->next;
		current->next = todelete->next;
		todelete->next->prev = current;
		delete todelete;
		size--;
	}
}

template<typename T>
T& List<T>::operator[](const int index)
{
	if (index <= size / 2)
	{
		int counter = 0;
		Node<T>* current = this->head;
		while (current != nullptr)
		{
			if (counter == index)
			{
				return current->data;
			}
			current = current->next;
			counter++;
		}
	}
	else
	{
		int counter = size - 1;
		Node<T>* current = this->tail;
		while (current != nullptr)
		{
			if (counter == index)
			{
				return current->data;
			}
			current = current->prev;
			counter--;
		}
	}
}

template<typename T>
void List<T>::PushBack(T data)
{
	if (head == nullptr)
	{
		head = tail = new Node<T>(data);
	}
	else
	{
		tail = tail->next = new Node<T>(data, tail);
	}
	size++;
}

template<typename T>
void List<T>::PopFront()
{
	if (size == 1)
	{
		delete head;
		head = nullptr;
		tail = nullptr;
		size--;
		return;
	}
	head = head->next;
	delete head->prev;
	head->prev = nullptr;
	size--;
}

template<typename T>
void List<T>::InsertList(List<T>&temp, int index)
{
	for (int i = 0; i < temp.GetSize(); i++)
	{
		Insert(temp[i], index + i);
	}
}

template<typename T>
int List<T>::GetSize()
{
	return size;
}

template <typename T>
List<T>::~List()
{
	while (size)
	{
		PopFront();
	}
}

#endif
